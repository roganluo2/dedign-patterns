工厂模式：
1、用UML绘制出三种工厂模式的类结构图。
见工厂模式类图1.1
2、深刻理解产品族和产品等级结构之间的关系。
产品族，就是厂家生产的一个产品可以有多个产品部件组成，这些多个产品就是不同的产品族。
产品等级：不同的工厂生产上述的产品族，生产产品的结果相同。
产品族 – 可以理解成手机的几个主要配件：摄像头，通话装置，音频模块，CPU
产品等级- 理解成个不同手机厂商生产的商品
3、自主完成三种工厂模式的代码实现，理解简单工厂、工厂方法和抽象工厂的区别。
代码：com.gupaoedu.factory
简单工厂就是一个大杂烩，你告诉我啥，我搞一搞，都能造出来，缺点就是我不会，还要去学一下，理解为简单工厂代码修改；
工厂方法：工厂与产品是一一对应的关系，专人作专事，华为只生产华为的手机，小米只生产小米的手机。
抽象工厂：构成一个产品需要多个产品的参与，这些产品构成了产品族，不同的厂家，类比为抽象工厂的实现。




单例模式
1、熟练掌握单例模式的常见写法。
2、思考破坏单例模式的方式有哪些？并且归纳总结。
   2.1 反射， 通过暴力调用私有构造函数的newinstance方法实例化， 解决方法：在构造函数中抛出异常
   2.2 序列化，通过序列化，反序列化的时候，如果类中有构造函数，jdk会调用newInstance实例化对象，破坏单例
       但是jdk会检查类中有没有readResolve方法，如果有该方法，通过invoke反射调用，返回该方法中返回的实例，避免生产多实例。
   2.3 枚举式注册单例，有天然预防被破话的功能，针对反射破坏，jdk层面限制了构造方法的调用，对于序列化破坏，枚举类型实例是在类
   被加载的时候，就已经完成初始化，在readEnums时候，直接获取类加载时创建的enum实例对象，所以不会破坏到单例。
3、梳理内部类的执行逻辑，并画出时序图。
图2.1 静态内部类时序图

原型模式
1、运用原型模式重构一段业务代码。
com.gupaoedu.prototype.shadow实现了相同属性的拷贝


代理模式
1、仿JDK动态代理实现原理，自己手写一遍。
写了一个自定义代理CtmProxy类，CtmInvocationHandler
2、思考：为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？
接口的数量标识，在class类文件中，用两个byte位来存储，最大可以存65535个
3、结合自身的业务场景用代理模式进行重构。
针对service方法，打印了入库日志，出口日志，方便线上问题定位日志。


委派及策略模式：
1、举例Spring源码中你见过的委派模式，并画出类关系图。
图5.1 委派模式类图Databinder.jpg
2、利用策略模式重构一段业务代码。
com.gupaoedu.strategy

模板模式及适配器模式
1、思考：模板模式除了继承以外，还有哪些实现方式？
Java回调方式，就是利用匿名内部类的方式，构建模板类的实例，然后重新对应的模板方法
2、使用适配模式，重构一段需要升级功能且兼容老系统的业务代码。
com.gupaoedu.adapter,实现了对老系统中短信发送平台对接的切换


观察者模式及装饰模式
1、思考并总结装饰者模式和适配器模式的根本区别。
装饰者模式：装饰类会继承被装饰的类，或者实现被装饰的接口，装饰类是被装饰类的子类，是is-a的关系。装饰者同时持有被装饰类的实例对象，可以对原有对象进行扩展，
相比继承，装饰器可以动态组合，把使用权交给用户，动态组合需要的功能。装饰器模式是一种特殊的适配器模式。
适配器模式：持有被适配对象的引用，但是不继承被适配对象，has-a的关系，适配器是将已有的功能，和新增的功能做一个整合，在不违背开闭原则基础上，对原来功能进行升级兼容，转换

2、用Guava API实现GPer社区提问通知的业务场景。
com.gupaoedu.observer.useguava


1、用一句自己的话总结学过的设计模式（要精准）。
简单工厂  ： 一个万能的工厂，可以制造很多产品
工厂方法  ： 职责单一，一个工厂一种产品，专人做专事
抽象工厂  ： 抽象的工厂功能很强大，可以制造一个产品族，不同的实现工厂制作的产品等级不一样
单例模式  ： 只需要一个实例
原型模式  ： 根据模板复制克隆
静态代理  ： 总经理助理，只能为一个boss排忧解难
动态代理模式  ： 字节码重组技术，完成对目标对象的功能增强
委派模式  ：任务派发器，干活是你的，功劳是我的
策略模式  ： 减少if else case的出现
模板模式  ：流程规范化，变化继承加
适配器模式 ：结识新朋友，兼容老朋友
装饰模式   ：is-a关系，同宗同源，龙生龙，凤生凤
观察者模式 ：